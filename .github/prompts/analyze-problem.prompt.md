```prompt
# Analyze Problem Before Implementation

Before writing any code, thoroughly analyze the problem to understand its requirements, identify patterns, and plan your approach. This upfront analysis will lead to better solutions and deeper learning.

## Instructions

1. **Read the SPECIFICATION.md file** in the current day folder carefully, multiple times if needed.

2. **Complete the following analysis** and document your thinking (you can write this analysis in the SPECIFICATION.md Notes section or discuss it with me):

## Analysis Framework

### 1. Problem Breakdown
Break the problem into smaller sub-problems:
- What is the input format and structure?
- What transformations or operations are needed?
- What is the output format?
- Can this be solved in stages/phases?
- Are there dependencies between sub-problems?

### 2. Pattern Recognition
Identify which algorithmic patterns or techniques apply:
- **Data Structure Patterns:**
  - Arrays/Lists (iteration, indexing)
  - Hash Maps/Dictionaries (lookups, counting, grouping)
  - Sets (uniqueness, membership testing)
  - Stacks (LIFO operations, backtracking)
  - Queues (FIFO operations, BFS)
  - Heaps (priority queue, top-k elements)
  - Trees/Graphs (hierarchical/connected data)

- **Algorithmic Patterns:**
  - Sorting (ordering, finding min/max)
  - Searching (binary search, linear search)
  - Two Pointers (pair finding, sliding window)
  - Sliding Window (subarray/substring problems)
  - Recursion (divide and conquer, tree traversal)
  - Dynamic Programming (overlapping subproblems, optimal substructure)
  - Greedy (local optimal choices)
  - Graph Traversal (BFS, DFS, shortest path)
  - Backtracking (exploring possibilities)
  - String Manipulation (parsing, pattern matching)
  - Math/Number Theory (factors, primes, modular arithmetic)

- **Which patterns do you recognize in this problem?**

### 3. Solution Approaches
Consider multiple approaches before choosing one:

#### Approach 1: [Name, e.g., "Brute Force"]
- **Description:** How would this work?
- **Pros:** What are the advantages?
- **Cons:** What are the disadvantages?
- **Time Complexity:** O(?)
- **Space Complexity:** O(?)

#### Approach 2: [Name, e.g., "Optimized with Hash Map"]
- **Description:** How would this work?
- **Pros:** What are the advantages?
- **Cons:** What are the disadvantages?
- **Time Complexity:** O(?)
- **Space Complexity:** O(?)

#### Approach 3: [Optional - if applicable]
- **Description:** How would this work?
- **Pros:** What are the advantages?
- **Cons:** What are the disadvantages?
- **Time Complexity:** O(?)
- **Space Complexity:** O(?)

**Chosen Approach:** Which one will you implement and why?

### 4. Complexity Prediction
Before implementing, predict the complexity of your chosen approach:

**Part One:**
- **Time Complexity:** O(?)
  - Justify: Why this complexity?
- **Space Complexity:** O(?)
  - Justify: Why this complexity?

**Part Two (if known):**
- **Time Complexity:** O(?)
  - Justify: Why this complexity?
- **Space Complexity:** O(?)
  - Justify: Why this complexity?

**Constraints to Consider:**
- What is n (the input size)?
- Are there any special constraints mentioned?
- Will the algorithm scale for large inputs?

### 5. Edge Cases
List potential edge cases before implementing:

**Input Edge Cases:**
- Empty input / no data
- Single element
- All elements the same
- Very large numbers
- Negative numbers (if applicable)
- Zero values
- Maximum possible input size

**Logic Edge Cases:**
- Off-by-one errors (array indices, loop bounds)
- Integer overflow (for very large calculations)
- Division by zero
- Null/None values
- String parsing issues (extra spaces, formatting)

**Specific to This Problem:**
- [List problem-specific edge cases here]

### 6. Implementation Plan
Create a step-by-step plan:

**Step 1:** Parse input
- What data structure will hold the parsed data?
- What validation is needed?

**Step 2:** Process data
- What is the main algorithm/logic?
- Are there helper functions needed?

**Step 3:** Return result
- What format should the output be?
- Any final transformations needed?

## After Analysis

Once you've completed this analysis:
1. Discuss your thinking with me (or document it in SPECIFICATION.md Notes section)
2. Verify your understanding by explaining the problem in your own words
3. Only then proceed to create tests and implement the solution

## Benefits of This Process

- **Prevents incorrect implementations** - catch misunderstandings early
- **Leads to better solutions** - consider multiple approaches, not just the first idea
- **Improves learning** - deliberate practice in pattern recognition
- **Builds intuition** - complexity analysis before coding improves estimation skills
- **Saves time** - less debugging when you plan first


Don't skip this analysis step! It is crucial for effective problem solving.
Don't create tests or write code until this analysis is complete and discussed.

```
